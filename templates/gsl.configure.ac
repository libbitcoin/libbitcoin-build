.template 0
###############################################################################
# Copyright (c) 2014-2025 libbitcoin developers (see COPYING).
#
# GSL generate libbitcoin configure.ac.
#
# This is a code generator built using the iMatix GSL code generation
# language. See https://github.com/imatix/gsl for details.
###############################################################################
# Functions
###############################################################################

function substitute_system_include(variable_name)
    return "`echo ${$(my.variable_name)} | $SED s/^-I/-isystem/g | $SED s/' -I'/' -isystem'/g`"
endfunction

function format_template_files(configure)
    define my.configure = format_template_files.configure
    define my.template_files = ""
    for my.configure.template as _template
        require(_template, "template", "name")
        my.template_files += " $(_template.name)"
    endfor _template
    return trim_left(my.template_files)
endfunction

function is_flag_prefixed(configure, prefix)
    define my.configure = is_flag_prefixed.configure
    define my.found = my.configure->flag(starts_with(flag.name, my.prefix))?
    return defined(my.found)
endfunction

function find_flag_prefixed(configure, prefix)
    define my.configure = find_flag_prefixed.configure
    return my.configure->flag(starts_with(flag.name, my.prefix))
endfunction

# Return PREPROC|COMPILE|LINK
function get_flags_check(flag)
    define my.flag = get_flags_check.flag
    if (is_cpp_flag(my.flag))
        return "PREPROC"
    elsif (is_ccc_flag(my.flag) | is_cxx_flag(my.flag))
        # Is this intended to be both C and C++?
        return "COMPILE"
    elsif (is_link_flag(my.flag))
        return "LINK"
    endif
    define my.context = my.flag.context ? ""
    abort "Invalid flag context: '$(my.context)'."
endfunction

function get_option_type(option)
    define my.option = get_option_type.option
    require(my.option, "option", "type")
    if (my.option.type = "enable" | my.option.type = "with")
        return my.option.type
    endif
    abort "Invalid repository.option.type: $(my.option.type)."
endfunction

function get_option_default(option)
    define my.option = get_option_default.option
    return defined(my.option.default) ??\
        " @<:@default=$(my.option.default)@:>@" ? ""
endfunction

# For some reason all-am requires we make the pc file, so for now we always
# define at least an empty package element.
function get_package_files(repository)
    define my.repository = get_package_files.repository
    define my.make = my.repository->make
    define my.packages = ""
    for my.repository.package as _package where defined(_package.library)
        define my.product = find_library_product(_package.library, my.make,\
            my.repository)?
        #if (defined(my.product))
            # TODO: define package name conditionally in configure.ac.
            #if (is_optional_element(my.product))
            #    abort "Conditional pkg-config not yet supported: $(_package.library)"
            #endif
            define my.package = get_package_name(_package)
            my.packages += " $(my.package).pc"
        #endif
    endfor
    return my.packages
endfunction

function render_define_item(item, configure)
    define my.define = render_define_item.item
    define my.configure = render_define_item.configure
    if defined(my.define.name)
        render_define(my.define, my.configure)
    elsif (defined(my.define.export))
        render_define_export(my.define)
    else
        render_define_header(my.define)
    endif
endfunction

function matches_element_name(collection, name)
    define my.collection = matches_element_name.collection
    return (count(my.collection.element, (count.name = my.name)) > 0)
endfunction

function discover_systems(repository, systems)
    define my.repository = discover_systems.repository
    define my.root = discover_systems.systems

    for my.repository->configure.dependency as _dependency\
        where defined(_dependency.system)

        define my.name = _dependency.system
        if (!matches_element_name(my.root, my.name))
            new my.root.element as _element
                _element.name = my.name
            endnew
        endif
    endfor

    for my.repository->configure.dependency as _dependency\
        where defined(_dependency.system_exclude)

        define my.name = _dependency.system_exclude
        if (!matches_element_name(my.root, my.name))
            new my.root.element as _element
                _element.name = my.name
            endnew
        endif
    endfor
endfunction

function initialize_systems_flags(repository)
    define my.repository = initialize_systems_flags.repository
    define my.sentinel = "*"

    new systems as _systems
        discover_systems(my.repository, _systems)

        if (count(_systems.element, 1) > 0)
            emit_initialize_platforms_declaration(_systems, my.sentinel)
            emit_initialize_platforms_case(_systems, my.sentinel)
        endif
    endnew
endfunction

function get_platform_test(dependency)
    define my.dependency = get_platform_test.dependency
    return is_empty(my.dependency.system)\
        ?? ""\
        ?  "test \"\$platform_$(my.dependency.system:c)\" = \"yes\""
endfunction

function get_platform_exclude_test(dependency)
    define my.dependency = get_platform_exclude_test.dependency
    return is_empty(my.dependency.system_exclude)\
        ?? ""\
        ?  "test \"\$platform_$(my.dependency.system_exclude:c)\" = \"no\""
endfunction

function get_case_platform(dependency, sentinel)
    define my.dependency = get_case_platform.dependency
    return is_empty(my.dependency.system)\
        ?? my.sentinel ?  "*$(my.dependency.system:c)*"
endfunction

function get_case_platform_exclude(dependency, sentinel)
    define my.dependency = get_case_platform_exclude.dependency
    return is_empty(my.dependency.system_exclude)\
        ?? my.sentinel ?  "*$(my.dependency.system_exclude:c)*"
endfunction

###############################################################################
# Macros
###############################################################################
.endtemplate
.template 1
.
.#-----------------------------------------------------------------------------
.# AC_LANG_PROGRAM tests
.#-----------------------------------------------------------------------------
.macro render_test_program(program, indent, prefix, suffix)
.   my.program = render_test_program.program
.   my.indent = render_test_program.indent
.   my.prefix = render_test_program.prefix
.   my.suffix = render_test_program.suffix
.
$(my.prefix)AC_LANG_PROGRAM(
  $(my.indent)[[
.   for my.program.include as _include
    $(my.indent)#include <$(_include.header)>
.   endfor
  $(my.indent)]],
  $(my.indent)[[
.   for my.program.loc as _loc
    $(my.indent)$(_loc)
.   endfor
  $(my.indent)]])$(my.suffix)
.endmacro
.
.#-----------------------------------------------------------------------------
.# Initialize
.#-----------------------------------------------------------------------------
.macro initialize_configure(repository)
.   define my.repository = initialize_configure.repository
.   require(my.repository, "repository", "email")
.   require(my.repository, "repository", "name")
.   require(my.repository, "repository", "version")
.
# Requires Automake 1.14 or newer.

# Declare the required version of Autoconf.
AC_PREREQ([2.65])

# Process command-line arguments and perform initialization and verification.
AC_INIT([$(my.repository.name)], [$(my.repository.version)], [$(my.repository.email)])

# Do compilation tests.
AC_LANG(C++)

# Specify the temporary directory for build tools.
AC_CONFIG_AUX_DIR([build-aux])

# Specify the directory of additional local Autoconf macros.
AC_CONFIG_MACRO_DIR([m4])

# Run macros for operation of generated Makefiles, enable non-recursive make.
# Unless [foreign] is specified standard GNU files will be required,
# specifically: AUTHORS, COPYING, INSTALL, NEWS, README and ChangeLog.
AM_INIT_AUTOMAKE([subdir-objects])

# Enable C and POSIX extensions that may be disabled on certain platforms.
AC_USE_SYSTEM_EXTENSIONS

# Enable the archiver.
AM_PROG_AR

# Initialize libtool.
LT_PREREQ(2.4.2)

# Enable shared libraries if available, and static if they don't conflict.
LT_INIT
AC_SUBST([LIBTOOL_DEPS])

# Determine C++ compiler to use.
AC_PROG_CXX

# Enable sed for substitution.
AC_PROG_SED

# Compute the canonical host-system type variable host, including host_os.
AC_CANONICAL_HOST

# Enable silent rules option.
m4_ifdef([AM_SILENT_RULES], [AM_SILENT_RULES([yes])])

# Check for pkg-config.
PKG_PROG_PKG_CONFIG
AS_IF([test -n "$PKG_CONFIG"], [],
    [AC_MSG_ERROR([pkg-config is required but was not found.])])

AS_CASE([${enable_static}],
    [yes], [AC_SUBST([PKG_CONFIG], ["$PKG_CONFIG --static"])],
    [])

.heading2("Declare environment variables that affect the build.")
AC_ARG_VAR([CC], "C compiler to use, such as gcc or clang")
AC_ARG_VAR([CXX], "C++ compiler to use, such as g++ or clang++")
AC_ARG_VAR([PKG_CONFIG_PATH], "Additional directories for package discovery.")

.endmacro
.
.macro emit_initialize_platforms_declaration(systems, sentinel)
.   define my.systems = emit_initialize_platforms_declaration.systems
# Platform indicators
.   for my.systems.element as _element
.       if (!(_element.name = my.sentinel))
platform_$(_element.name:c)="no"
.       endif
.   endfor

.endmacro
.
.macro emit_initialize_platforms_case(systems, sentinel)
.   define my.systems = emit_initialize_platforms_case.systems
.
AS_CASE([${host_os}],
.   for my.systems.element as _element
.       if (!(_element.name = my.sentinel))
    [*$(_element.name)*],
    [platform_$(_element.name:c)="yes"],
.       endif
.   endfor
    [])

.endmacro
.
.#-----------------------------------------------------------------------------
.# AX_CXX_COMPILE_STDCXX
.#-----------------------------------------------------------------------------
.macro require_stdcxx(repository)
.   define std_prefix = "std=c++"
.   define my.repository = require_stdcxx.repository
.   if (is_flag_prefixed(my.repository->configure, std_prefix))
.       define my.flag = find_flag_prefixed(my.repository->configure, std_prefix)
.       define my.standard = right(my.flag.name,\
            string.length(my.flag.name) - string.length(std_prefix))
.heading2("Check for baseline language coverage in the compiler for the C++$(my.standard) standard.")
AX_CXX_COMPILE_STDCXX([$(my.standard)], [noext], [mandatory])

.   endif
.endmacro
.
.#-----------------------------------------------------------------------------
.# AC_ARG_ENABLE | AC_ARG_WITH
.#-----------------------------------------------------------------------------
.macro render_option(option)
.   define my.option = render_option.option
.   require(my.option, "option", "description")
.   require(my.option, "option", "name")
.   require(my.option, "option", "type")
.
.   define my.example = my.option.example ? ""
.   define my.type = get_option_type(my.option)
.   define my.symbol = get_option_symbol(my.option)
.   define my.default = get_option_default(my.option)
.
.   define my.implement = is_true(inherited) ?? "Inherit" ? "Implement"
.   define my.output = is_true(my.option.substitute) ?? " and output ${$(my.option.name:c)}" ? ""
.   define my.defines = defined(my.option.define) ?? " and define $(my.option.define:upper,c)" ? ""
.   define my.conditional = is_true(my.option.conditional) ?? " and declare $(my.symbol:upper)" ? ""
.   heading2("$(my.implement) --$(my.type)-$(my.option.name)$(my.defines)$(my.output)$(my.conditional).")
.
.   if (!is_true(my.option.inherited))
AC_MSG_CHECKING([--$(my.type)-$(my.option.name) option])
AC_ARG_$(my.type:upper)([$(my.option.name)],
    AS_HELP_STRING([--$(my.type)-$(my.option.name)$(my.example)],
        [$(my.option.description)$(my.default)]),
    [$(my.symbol)=$$(my.type)val],
    [$(my.symbol)=$(my.option.default)])
AC_MSG_RESULT([$$(my.symbol)])
.   endif
.
.   if (!is_empty(my.option.define))
AS_CASE([${$(my.symbol)}], [yes], AC_DEFINE([$(my.option.define:upper,c)]))
.   endif
.
.   if (is_true(my.option.substitute) & defined(my.option.value))
AS_CASE([${$(my.symbol)}], [yes], AC_SUBST([$(my.option.name:c)], [$(my.option.value)]))
.   elsif (is_true(my.option.substitute))
AC_SUBST([$(my.symbol)])
.   endif
.
.   if (is_true(my.option.conditional))
AM_CONDITIONAL([$(my.symbol:upper)], [test x$$(my.symbol) != xno])
.   endif

.endmacro
.
.#-----------------------------------------------------------------------------
.# AC_DEFINE
.#-----------------------------------------------------------------------------
.macro render_define(item, configure)
.   define my.define = render_define.item
.   define my.configure = render_define.configure
.   require(my.define, "define", "name")
.   define my.uname = "$(my.define.name:upper,c)"
.   define my.heading = defined(my.define.option) ?? \
        "Conditionally define the preprocessor symbol $(my.uname)." ? \
        "Unconditionally define the preprocessor symbol $(my.uname)."
.
.   define my.define_prefix = defined(my.define.option) ?? "    " ? ""
.
.   heading2(my.heading)

.   if (!is_empty(my.define.comment))
.       heading3(my.define.comment)
.   endif
.
.   if (defined(my.define.option))
.       define my.option = my.configure->option(option.name = my.define.option)
.       if (!defined(my.option))
.       endif
.       define my.symbol = get_option_symbol(my.option)
.       define my.type = get_option_type(my.option)
.
AS_IF([test x${$(my.symbol)} != "xno"], [
.   endif
.
.   if (defined(my.define.value))
$(my.define_prefix)AC_DEFINE([$(my.uname)], [$(my.define.value)])
.   else
$(my.define_prefix)AC_DEFINE([$(my.uname)])
.   endif
.
.   if (defined(my.define.substitute))
.       define my.subvalue = defined(my.define.value) ?? my.define.value ? "-D$(my.uname)"
$(my.define_prefix)AC_SUBST([$(my.define.substitute)], $(my.subvalue)])
.   endif
.
.   if (defined(my.define.option))
    ])
.   endif
.
.endmacro
.
.#-----------------------------------------------------------------------------
.# AC_CHECK_HEADERS
.#-----------------------------------------------------------------------------
.macro render_define_header(item)
.   define my.define = render_define_header.item
.   require(my.define, "define", "header")
.   define my.symbol = "HAVE_$(my.define.header:upper,c)"
.   heading2("Conditionally define the preprocessor symbol $(my.symbol).")
AC_CHECK_HEADERS([$(my.define.header)])

.endmacro
.
.#-----------------------------------------------------------------------------
.# AC_CHECK_DECLS
.#-----------------------------------------------------------------------------
.macro render_define_export(item)
.   define my.define = render_define_export.item
.   require(my.define, "define", "header")
.   require(my.define, "define", "export")
.   define my.header_symbol = "HAVE_$(my.define.header:upper,c)"
.   define my.export_symbol = "HAVE_DECL_$(my.define.export:upper,c)"
.   heading2("Conditionally define the preprocessor symbol $(my.export_symbol).")
AC_CHECK_HEADERS([$(my.define.header)],
    [AC_CHECK_DECLS([$(my.define.export)], [], [],
        [#if $(my.header_symbol)
         #include <$(my.define.header)>
         #endif])])

.endmacro
.
.#-----------------------------------------------------------------------------
.# AX_JAVA_DEVEL
.#-----------------------------------------------------------------------------
.macro check_java(dependency, configure)
.   define my.dependency = check_java.dependency
.   define my.configure = check_java.configure
.   require(my.dependency, "dependency", "name")
.
.   define my.name = my.dependency.name
.   define my.cname = "$(my.name:c)"
.   define my.symbol = find_option_symbol(my.dependency, my.configure)?
.   define my.show_option = !is_empty(my.symbol) ?? " if --$(my.symbol)" ? ""
.   heading2("Require $(my.name)$(my.show_option) and output ${JAR/JAVAC/javadir} and ${$(my.cname)_CPPFLAGS}.")
.   if (!is_empty(my.dependency.comment))
.       heading3("$(my.dependency.comment)")
.   endif
.   if (is_empty(my.symbol))
AX_JAVA_DEVEL
AC_SUBST([$(my.cname)_CPPFLAGS], [${JAVA_CPPFLAGS}])
AC_SUBST([$(my.cname)_ISYS_CPPFLAGS], [$(substitute_system_include("JAVA_CPPFLAGS"))])
AC_MSG_NOTICE([$(my.cname)_CPPFLAGS : ${$(my.cname)_CPPFLAGS}])
AC_MSG_NOTICE([$(my.cname)_ISYS_CPPFLAGS : ${$(my.cname)_ISYS_CPPFLAGS}])
.   else
AS_CASE([${$(my.symbol)}], [yes],
    [AX_JAVA_DEVEL
     AC_SUBST([$(my.cname)_CPPFLAGS], [${JAVA_CPPFLAGS}])
     AC_SUBST([$(my.cname)_ISYS_CPPFLAGS], [$(substitute_system_include("JAVA_CPPFLAGS"))])
     AC_MSG_NOTICE([$(my.cname)_CPPFLAGS : ${$(my.cname)_CPPFLAGS}])
     AC_MSG_NOTICE([$(my.cname)_ISYS_CPPFLAGS : ${$(my.cname)_ISYS_CPPFLAGS}])])
.   endif

AS_CASE([${enable_isystem}],[yes],
    [AC_SUBST([$(my.cname)_BUILD_CPPFLAGS], [${$(my.cname)_ISYS_CPPFLAGS}])],
    [AC_SUBST([$(my.cname)_BUILD_CPPFLAGS], [${$(my.cname)_CPPFLAGS}])])

AC_MSG_NOTICE([$(my.cname)_BUILD_CPPFLAGS : ${$(my.cname)_BUILD_CPPFLAGS}])

.endmacro
.
.#-----------------------------------------------------------------------------
.# AX_PYTHON_DEVEL
.#-----------------------------------------------------------------------------
.macro check_python(dependency, configure)
.   define my.dependency = check_python.dependency
.   define my.configure = check_python.configure
.   require(my.dependency, "dependency", "name")
.
.   define my.name = my.dependency.name
.   define my.cname = "$(my.name:c)"
.   define my.version = my.dependency.version
.   define my.symbol = find_option_symbol(my.dependency, my.configure)?
.   define my.show_option = !is_empty(my.symbol) ?? " if --$(my.symbol)" ? ""
.   heading2("Require $(my.name) of at least version $(my.version)$(my.show_option) and output ${$(my.cname)_CPPFLAGS}.")
.   if (!is_empty(my.dependency.comment))
.       heading3("$(my.dependency.comment)")
.   endif
.   if (is_empty(my.symbol))
AM_PATH_PYTHON([$(my.version)],
    [AX_PYTHON_DEVEL
     AC_SUBST([$(my.cname)_CPPFLAGS], [${PYTHON_CPPFLAGS}])
     AC_SUBST([$(my.cname)_ISYS_CPPFLAGS], [$(substitute_system_include("PYTHON_CPPFLAGS"))])
     AC_MSG_NOTICE([$(my.cname)_CPPFLAGS : ${$(my.cname)_CPPFLAGS}])
     AC_MSG_NOTICE([$(my.cname)_ISYS_CPPFLAGS : ${$(my.cname)_ISYS_CPPFLAGS}])])
.   else
AS_CASE([${$(my.symbol)}], [yes],
    [AM_PATH_PYTHON([$(my.version)],
        [AX_PYTHON_DEVEL
         AC_SUBST([$(my.cname)_CPPFLAGS], [${PYTHON_CPPFLAGS}])
         AC_SUBST([$(my.cname)_ISYS_CPPFLAGS], [$(substitute_system_include("PYTHON_CPPFLAGS"))])
         AC_MSG_NOTICE([$(my.cname)_CPPFLAGS : ${$(my.cname)_CPPFLAGS}])])
         AC_MSG_NOTICE([$(my.cname)_ISYS_CPPFLAGS : ${$(my.cname)_ISYS_CPPFLAGS}])])
.   endif

AS_CASE([${enable_isystem}],[yes],
    [AC_SUBST([$(my.cname)_BUILD_CPPFLAGS], [${$(my.cname)_ISYS_CPPFLAGS}])],
    [AC_SUBST([$(my.cname)_BUILD_CPPFLAGS], [${$(my.cname)_CPPFLAGS}])])

AC_MSG_NOTICE([$(my.cname)_BUILD_CPPFLAGS : ${$(my.cname)_BUILD_CPPFLAGS}])

.endmacro
.
.#-----------------------------------------------------------------------------
.# AM_ICONV
.#-----------------------------------------------------------------------------
.macro check_iconv(dependency, configure)
.   define my.dependency = check_iconv.dependency
.   define my.configure = check_iconv.configure
.   require(my.dependency, "dependency", "name")
.
.   define my.name = my.dependency.name
.   define my.cname = "$(my.name:c)"
.   define my.symbol = find_option_symbol(my.dependency, my.configure)?
.   define my.show_option = !is_empty(my.symbol) ?? " if --$(my.symbol)" ? ""
.   heading2("Require $(my.name)$(my.show_option) and output ${$(my.cname)_CPPFLAGS/LIBS}.")
.   if (!is_empty(my.dependency.comment))
.       heading3("$(my.dependency.comment)")
.   endif
.   if (is_empty(my.symbol))
AM_ICONV
AC_SUBST([iconv_CPPFLAGS], [${INCICONV}])
AC_SUBST([iconv_ISYS_CPPFLAGS], [$(substitute_system_include("INCICONV"))])
AC_SUBST([iconv_LIBS], [${LIBICONV}])
AC_MSG_NOTICE([$(my.cname)_CPPFLAGS : ${$(my.cname)_CPPFLAGS}])
AC_MSG_NOTICE([$(my.cname)_ISYS_CPPFLAGS : ${$(my.cname)_ISYS_CPPFLAGS}])
AC_MSG_NOTICE([$(my.cname)_LIBS : ${$(my.cname)_LIBS}])
.   else
AS_CASE([${$(my.symbol)}], [yes],
    AM_ICONV
    AC_SUBST([iconv_CPPFLAGS], [${INCICONV}])
    AC_SUBST([iconv_ISYS_CPPFLAGS], [$(substitute_system_include("INCICONV"))])
    AC_SUBST([iconv_LIBS], [${LIBICONV}])
    AC_MSG_NOTICE([$(my.cname)_CPPFLAGS : ${$(my.cname)_CPPFLAGS}])
    AC_MSG_NOTICE([$(my.cname)_ISYS_CPPFLAGS : ${$(my.cname)_ISYS_CPPFLAGS}])
    AC_MSG_NOTICE([$(my.cname)_LIBS : ${$(my.cname)_LIBS}]))
.   endif

AS_CASE([${enable_isystem}],[yes],
    [AC_SUBST([$(my.cname)_BUILD_CPPFLAGS], [${$(my.cname)_ISYS_CPPFLAGS}])],
    [AC_SUBST([$(my.cname)_BUILD_CPPFLAGS], [${$(my.cname)_CPPFLAGS}])])

AC_MSG_NOTICE([$(my.cname)_BUILD_CPPFLAGS : ${$(my.cname)_BUILD_CPPFLAGS}])

.endmacro # check_iconv
.
.#-----------------------------------------------------------------------------
.# AX_PTHREAD
.#-----------------------------------------------------------------------------
.macro emit_m4_ax_cpp_libs_macro(dependency, indent_length, trailing_indicator,\
    wrap)
.
.   define my.dependency = emit_m4_ax_cpp_libs_macro.dependency
.   require(my.dependency, "dependency", "name")
.
.   define my.cname = "$(my.dependency.name:c)"
.   define my.uname = "$(my.cname:upper)"
.   define my.prefix_bracket = is_true(my.wrap) ?? "[" ? ""
.   define my.suffix_bracket = is_true(my.wrap) ?? "]" ? ""
.   define my.indent_prefix = ""
.   while (my.indent_length > string.length(my.indent_prefix))
.       my.indent_prefix = " $(my.indent_prefix)"
.   endwhile
.
$(my.indent_prefix)$(my.prefix_bracket)AX_$(my.uname)(
    $(my.indent_prefix)[AC_SUBST([$(my.cname)_CPPFLAGS], [${$(my.uname)_CPPFLAGS}])
     $(my.indent_prefix)AC_SUBST([$(my.cname)_ISYS_CPPFLAGS], [$(substitute_system_include("$(my.uname)_CPPFLAGS"))])
.   if (my.cname = "pthread")
     $(my.indent_prefix)AC_SUBST([$(my.cname)_LIBS], [-lpthread])
.   else
     $(my.indent_prefix)AC_SUBST([$(my.cname)_LIBS], [${$(my.uname)_LIBS}])
.   endif
     $(my.indent_prefix)AC_MSG_NOTICE([$(my.cname)_CPPFLAGS : ${$(my.cname)_CPPFLAGS}])
     $(my.indent_prefix)AC_MSG_NOTICE([$(my.cname)_ISYS_CPPFLAGS : ${$(my.cname)_ISYS_CPPFLAGS}])],
    $(my.indent_prefix)[AC_MSG_ERROR([$(my.cname) library is required but was not found.])])

$(my.indent_prefix)AS_CASE([${enable_isystem}],[yes],
    $(my.indent_prefix)[AC_SUBST([$(my.cname)_BUILD_CPPFLAGS], [${$(my.cname)_ISYS_CPPFLAGS}])],
    $(my.indent_prefix)[AC_SUBST([$(my.cname)_BUILD_CPPFLAGS], [${$(my.cname)_CPPFLAGS}])])

$(my.indent_prefix)AC_MSG_NOTICE([$(my.cname)_BUILD_CPPFLAGS : ${$(my.cname)_BUILD_CPPFLAGS}])$(my.suffix_bracket)$(my.trailing_indicator)
.endmacro # emit_m4_ax_cpp_libs_macro
.
.macro emit_m4_ax_cpp_libs_conditional_platform(dependency, indent_length,\
    trailing_indicator, wrap)
.
.   define my.dependency = emit_m4_ax_cpp_libs_conditional_platform.dependency
.   require(my.dependency, "dependency", "name")
.
.   define my.name = "$(my.dependency.name)"
.   define my.platform = get_case_platform(my.dependency, "")
.   define my.platform_exclude = get_case_platform_exclude(my.dependency, "")
.
.   define my.prefix_bracket = is_true(my.wrap) ?? "[" ? ""
.   define my.suffix_bracket = is_true(my.wrap) ?? "]" ? ""
.   define my.indent_prefix = ""
.   while (my.indent_length > string.length(my.indent_prefix))
.       my.indent_prefix = " $(my.indent_prefix)"
.   endwhile
.
.   if (is_empty(my.platform) & is_empty(my.platform_exclude))
.       emit_m4_ax_cpp_libs_macro(my.dependency, my.indent_length,\
            my.trailing_indicator, my.wrap)
.   else
$(my.indent_prefix)$(my.prefix_bracket)AS_CASE([${host_os}],
.       if (!is_empty(my.platform_exclude))
    $(my.indent_prefix)[$(my.platform_exclude)],
    $(my.indent_prefix)[AC_SUBST([$(my.name:c)_LIBS], [])],
.       endif
.       if (!is_empty(my.platform))
    $(my.indent_prefix)[$(my.platform)],
.           emit_m4_ax_cpp_libs_macro(my.dependency, my.indent_length + 4,\
                ",", "true")
    $(my.indent_prefix)[AC_SUBST([$(my.name:c)_LIBS], [])])$(my.suffix_bracket)$(my.trailing_indicator)
.       else
.           emit_m4_ax_cpp_libs_macro(my.dependency, my.indent_length + 4,\
                ")$(my.suffix_bracket)$(my.trailing_indicator)", "true")
.       endif
.   endif
.endmacro # emit_m4_ax_cpp_libs_conditional_platform
.
.macro emit_m4_ax_cpp_libs_conditional_option(dependency, configure,\
    indent_length, trailing_indicator, wrap)
.
.   define my.dependency = emit_m4_ax_cpp_libs_conditional_option.dependency
.   define my.configure = emit_m4_ax_cpp_libs_conditional_option.configure
.   require(my.dependency, "dependency", "name")
.
.   define my.name = "$(my.dependency.name)"
.   define my.symbol = find_option_symbol(my.dependency, my.configure)?
.
.   define my.prefix_bracket = is_true(my.wrap) ?? "[" ? ""
.   define my.suffix_bracket = is_true(my.wrap) ?? "]" ? ""
.   define my.indent_prefix = ""
.   while (my.indent_length > string.length(my.indent_prefix))
.       my.indent_prefix = " $(my.indent_prefix)"
.   endwhile
.
.   if (is_empty(my.symbol))
.       emit_m4_ax_cpp_libs_conditional_platform(\
            my.dependency, my.indent_length, my.trailing_indicator, my.wrap)
.   else
$(my.indent_prefix)$(my.prefix_bracket)AS_CASE([${$(my.symbol)}], [yes],
.       emit_m4_ax_cpp_libs_conditional_platform(\
            my.dependency, my.indent_length + 4, ",", "true")
    $(my.indent_prefix)[AC_MSG_NOTICE([$(my.symbol) value excludes $(my.name)])
     $(my.indent_prefix)[AC_SUBST([$(my.name:c)_LIBS], [])])$(my.suffix_bracket)$(my.trailing_indicator)
.   endif
.endmacro # emit_m4_ax_cpp_libs_conditional_option
.
.macro check_m4_cpp_libs_conditional(dependency, configure)
.   define my.dependency = check_m4_cpp_libs_conditional.dependency
.   define my.configure = check_m4_cpp_libs_conditional.configure
.   require(my.dependency, "dependency", "name")
.
.   define my.cname = "$(my.dependency.name:c)"
.   define my.uname = "$(my.cname:upper)"
.   define my.symbol = find_option_symbol(my.dependency, my.configure)?
.   define my.platform_test = get_platform_test(my.dependency)
.
.   define my.show_option = !is_empty(my.symbol) ?? " if --$(my.symbol)" ? ""
.   define my.show_system = is_empty(my.dependency.system) ?? "" ?\
        " if on $(my.dependency.system)"
.
.   define my.show_system_exclude = is_empty(my.dependency.system_exclude)\
        ?? "" ? " if not on $(my.dependency.system_exclude)"
.
.   heading2("Require $(my.cname)$(my.show_option)$(my.show_system)$(my.show_system_exclude) and output ${$(my.cname)_CPPFLAGS/LIBS}.")
.
.   if (!is_empty(my.dependency.comment))
.       heading3("$(my.dependency.comment)")
.   endif
.
.   if (my.cname = "pthread")
.       heading3("Hard wired -lpthread because AX_PTHREAD does not do it.")
.   endif
.
.   emit_m4_ax_cpp_libs_conditional_option(\
        my.dependency, my.configure, 0, "", "false")

AC_MSG_NOTICE([$(my.cname)_LIBS : ${$(my.cname)_LIBS}])

.endmacro # check_m4_cpp_libs_conditional
.
.#-----------------------------------------------------------------------------
.# AC_CHECK_LIB
.#-----------------------------------------------------------------------------
.macro emit_check_libs_macro(dependency, indent_length,\
    trailing_indicator, wrap)
.
.   define my.dependency = emit_check_libs_macro.dependency
.   require(my.dependency, "dependency", "name")
.
.   define my.cname = "$(my.dependency.name:c)"
.   define my.uname = "$(my.cname:upper)"
.   define my.prefix_bracket = is_true(my.wrap) ?? "[" ? ""
.   define my.suffix_bracket = is_true(my.wrap) ?? "]" ? ""
.   define my.indent_prefix = ""
.   while (my.indent_length > string.length(my.indent_prefix))
.       my.indent_prefix = " $(my.indent_prefix)"
.   endwhile
.
.   if (!is_empty(my.dependency.function))
$(my.indent_prefix)$(my.prefix_bracket)AC_CHECK_LIB([$(my.cname)], [$(my.dependency.function)],
    $(my.indent_prefix)[AC_SUBST([$(my.cname)_LIBS], [-l$(my.cname)])],
    $(my.indent_prefix)[AC_MSG_ERROR([$(my.cname) library is required but was not found.])])$(my.suffix_bracket)$(my.trailing_indicator)
.   endif
.endmacro # emit_check_libs_macro
.
.macro emit_check_libs_conditional_platform(dependency, indent_length,\
    trailing_indicator, wrap)
.
.   define my.dependency = emit_check_libs_conditional_platform.dependency
.   require(my.dependency, "dependency", "name")
.
.   define my.name = "$(my.dependency.name)"
.   define my.platform = get_case_platform(my.dependency, "")
.   define my.platform_exclude = get_case_platform_exclude(my.dependency, "")
.
.   define my.prefix_bracket = is_true(my.wrap) ?? "[" ? ""
.   define my.suffix_bracket = is_true(my.wrap) ?? "]" ? ""
.   define my.indent_prefix = ""
.   while (my.indent_length > string.length(my.indent_prefix))
.       my.indent_prefix = " $(my.indent_prefix)"
.   endwhile
.
.   if (is_empty(my.platform) & is_empty(my.platform_exclude))
.       emit_check_libs_macro(my.dependency, my.indent_length,\
            my.trailing_indicator, my.wrap)
.   else
$(my.indent_prefix)$(my.prefix_bracket)AS_CASE([${host_os}],
.       if (!is_empty(my.platform_exclude))
    $(my.indent_prefix)[$(my.platform_exclude)],
    $(my.indent_prefix)[AC_SUBST([$(my.name:c)_LIBS], [])],
.       endif
.       if (!is_empty(my.platform))
    $(my.indent_prefix)[$(my.platform)],
.           emit_check_libs_macro(my.dependency, my.indent_length + 4,\
                ",", "true")
    $(my.indent_prefix)[AC_SUBST([$(my.name:c)_LIBS], [])])$(my.suffix_bracket)$(my.trailing_indicator)
.       else
.           emit_check_libs_macro(my.dependency, my.indent_length + 4,\
                ")$(my.suffix_bracket)$(my.trailing_indicator)", "true")
.       endif
.   endif
.endmacro # emit_check_libs_conditional_platform
.
.macro emit_check_libs_conditional_option(dependency, configure,\
    indent_length, trailing_indicator, wrap)
.
.   define my.dependency = emit_check_libs_conditional_option.dependency
.   define my.configure = emit_check_libs_conditional_option.configure
.   require(my.dependency, "dependency", "name")
.
.   define my.name = "$(my.dependency.name)"
.   define my.symbol = find_option_symbol(my.dependency, my.configure)?

.
.   define my.prefix_bracket = is_true(my.wrap) ?? "[" ? ""
.   define my.suffix_bracket = is_true(my.wrap) ?? "]" ? ""
.   define my.indent_prefix = ""
.   while (my.indent_length > string.length(my.indent_prefix))
.       my.indent_prefix = " $(my.indent_prefix)"
.   endwhile
.
.   if (is_empty(my.symbol))
.       emit_check_libs_conditional_platform(\
            my.dependency, my.indent_length, my.trailing_indicator, my.wrap)
.   else
$(my.indent_prefix)$(my.prefix_bracket)AS_CASE([${$(my.symbol)}], [yes],
.       emit_check_libs_conditional_platform(\
            my.dependency, my.indent_length + 4, ",", "true")
    $(my.indent_prefix)[AC_MSG_NOTICE([$(my.symbol) value excludes $(my.name)])
     $(my.indent_prefix)[AC_SUBST([$(my.name:c)_LIBS], [])])$(my.suffix_bracket)$(my.trailing_indicator)
.   endif
.endmacro # emit_check_libs_conditional_option
.
.macro check_lib_dependency_conditional(dependency, configure)
.   define my.dependency = check_lib_dependency_conditional.dependency
.   define my.configure = check_lib_dependency_conditional.configure
.   require(my.dependency, "dependency", "name")
.
.   define my.cname = "$(my.dependency.name:c)"
.   define my.uname = "$(my.cname:upper)"
.   define my.symbol = find_option_symbol(my.dependency, my.configure)?
.   define my.platform_test = get_platform_test(my.dependency)
.
.   define my.show_option = !is_empty(my.symbol) ?? " if --$(my.symbol)" ? ""
.   define my.show_system = is_empty(my.dependency.system) ?? "" ?\
        " if on $(my.dependency.system)"
.
.   define my.show_system_exclude = is_empty(my.dependency.system_exclude)\
        ?? "" ? " if not on $(my.dependency.system_exclude)"
.
.   define my.output = is_empty(my.dependency.function) ?? "" ?\
        " and output ${$(my.cname)_LIBS}"
.
.   heading2("Require $(my.cname)$(my.show_option)$(my.show_system)$(my.show_system_exclude)$(my.output).")
.
.   if (!is_empty(my.dependency.comment))
.       heading3("$(my.dependency.comment)")
.   endif
.
.   emit_check_libs_conditional_option(\
        my.dependency, my.configure, 0, "", "false")

AC_MSG_NOTICE([$(my.cname)_LIBS : ${$(my.cname)_LIBS}])

.endmacro # check_lib_dependency_conditional
.
.#-----------------------------------------------------------------------------
.# AX_BOOST_BASE
.#-----------------------------------------------------------------------------
.macro check_boost(dependency)
.   define my.dependency = check_boost.dependency
.   require(my.dependency, "dependency", "version")
.
.   define my.version = my.dependency.version
.   define my.compiler = my.dependency.compiler?
.   define my.show_compiler = is_empty(my.compiler) ?? "" ? " if in $(my.compiler)"
.   define my.compiler_pattern = is_empty(my.compiler) ?? "*" ? "*$(my.compiler)*"
.   heading2("Require Boost of at least version $(my.version)$(my.show_compiler) and output ${boost_CPPFLAGS/LDFLAGS}.")
.   if (!is_empty(my.dependency.comment))
.       heading3("$(my.dependency.comment)")
.   endif
AS_CASE([${CC}], [$(my.compiler_pattern)],
    [AX_BOOST_BASE([$(my.version)],
        [AC_SUBST([boost_CPPFLAGS], [${BOOST_CPPFLAGS}])
         AC_SUBST([boost_ISYS_CPPFLAGS], [$(substitute_system_include("BOOST_CPPFLAGS"))])
         AC_SUBST([boost_LDFLAGS], [${BOOST_LDFLAGS}])
         AC_MSG_NOTICE([boost_CPPFLAGS : ${boost_CPPFLAGS}])
         AC_MSG_NOTICE([boost_ISYS_CPPFLAGS : ${boost_ISYS_CPPFLAGS}])
         AC_MSG_NOTICE([boost_LDFLAGS : ${boost_LDFLAGS}])],
        [AC_MSG_ERROR([Boost $(my.version) or later is required but was not found.])])])

AS_CASE([${enable_isystem}],[yes],
    [AC_SUBST([boost_BUILD_CPPFLAGS], [${boost_ISYS_CPPFLAGS}])],
    [AC_SUBST([boost_BUILD_CPPFLAGS], [${boost_CPPFLAGS}])])

AC_MSG_NOTICE([boost_BUILD_CPPFLAGS : ${boost_BUILD_CPPFLAGS}])

.endmacro
.
.#-----------------------------------------------------------------------------
.# AX_BOOST_XXX
.#-----------------------------------------------------------------------------
.macro check_boost_lib(dependency, configure)
.   define my.dependency = check_boost_lib.dependency
.   define my.configure = check_boost_lib.configure
.   require(my.dependency, "dependency", "name")
.
.   define my.symbol = find_option_symbol(my.dependency, my.configure)?
.   define my.cname = "$(my.dependency.name:c)"
.   define my.uname = "$(my.cname:upper)"
.   if (!is_empty(my.dependency.comment))
.       heading3("$(my.dependency.comment)")
.   endif
.
.   if (is_empty(my.symbol))
AX_$(my.uname)
AC_SUBST([$(my.cname)_LIBS], [${$(my.uname)_LIB}])
AC_MSG_NOTICE([$(my.cname)_LIBS : ${$(my.cname)_LIBS}])
.   else
AS_CASE([${$(my.symbol)}], [yes],
    [AX_$(my.uname)
     AC_SUBST([$(my.cname)_LIBS], [${$(my.uname)_LIB}])
     AC_MSG_NOTICE([$(my.cname)_LIBS : ${$(my.cname)_LIBS}])],
    [AC_SUBST([$(my.cname)_LIBS], [])])
.   endif

.endmacro
.
.#-----------------------------------------------------------------------------
.# PKG_CHECK_MODULES
.#-----------------------------------------------------------------------------
.macro check_package(dependency, configure)
.   define my.dependency = check_package.dependency
.   define my.configure = check_package.configure
.   require(my.dependency, "dependency", "name")
.   require(my.dependency, "dependency", "version")
.
.   define my.name = my.dependency.name
.   define my.cname = "$(my.dependency.name:c)"
.   define my.version = my.dependency.version
.   define my.default = my.dependency.default ? ""
.   define my.prefix = is_true(my.dependency.unprefixed) ?? "" ? "lib"
.   define my.symbol = find_option_symbol(my.dependency, my.configure)?
.   define my.check = "$(my.prefix)$(my.name) >= $(my.version)"
.   if (defined(my.symbol))
.       define my.option = my.configure->option(option.name = my.dependency.option)
.       define my.option.type = get_option_type(my.option)
.   endif
.   heading2("Require $(my.name) of at least version $(my.version) and output ${$(my.cname)_CPPFLAGS/LIBS/PKG}.")
.   if (!is_empty(my.dependency.comment))
.       heading3("$(my.dependency.comment)")
.   endif
.
.   if (is_empty(my.symbol))
PKG_CHECK_MODULES([$(my.cname)], [$(my.check)],
    [$(my.cname)_INCLUDEDIR="`$PKG_CONFIG --variable=includedir "$(my.check)" 2>/dev/null`"
     $(my.cname)_OTHER_CFLAGS="`$PKG_CONFIG --cflags-only-other "$(my.check)" 2>/dev/null`"],
    [AC_MSG_ERROR([$(my.check) is required but was not found.])])
AC_SUBST([$(my.cname)_PKG], ['$(my.check)'])
AC_SUBST([$(my.cname)_CPPFLAGS], [${$(my.cname)_CFLAGS}])
AS_IF([test x${$(my.cname)_INCLUDEDIR} != "x"],
    [AC_SUBST([$(my.cname)_ISYS_CPPFLAGS], ["-isystem${$(my.cname)_INCLUDEDIR} ${$(my.cname)_OTHER_CFLAGS}"])],
    [AC_SUBST([$(my.cname)_ISYS_CPPFLAGS], [${$(my.cname)_OTHER_CFLAGS}])])
AC_MSG_NOTICE([$(my.cname)_CPPFLAGS : ${$(my.cname)_CPPFLAGS}])
AC_MSG_NOTICE([$(my.cname)_ISYS_CPPFLAGS : ${$(my.cname)_ISYS_CPPFLAGS}])
AC_MSG_NOTICE([$(my.cname)_OTHER_CFLAGS : ${$(my.cname)_OTHER_CFLAGS}])
AC_MSG_NOTICE([$(my.cname)_INCLUDEDIR : ${$(my.cname)_INCLUDEDIR}])
AC_MSG_NOTICE([$(my.cname)_LIBS : ${$(my.cname)_LIBS}])
.   elsif (is_empty(my.dependency.extract))
AS_CASE([${$(my.symbol)}], [yes],
    [PKG_CHECK_MODULES([$(my.cname)], [$(my.check)],
        [$(my.cname)_INCLUDEDIR="`$PKG_CONFIG --variable=includedir "$(my.check)" 2>/dev/null`"
         $(my.cname)_OTHER_CFLAGS="`$PKG_CONFIG --cflags-only-other "$(my.check)" 2>/dev/null`"],
        [AC_MSG_ERROR([--$(my.option.type)-$(my.option.name) specified but $(my.check) was not found.])])
     AC_SUBST([$(my.cname)_PKG], ['$(my.check)'])
     AC_SUBST([$(my.cname)_CPPFLAGS], [${$(my.cname)_CFLAGS}])
     AS_IF([test x${$(my.cname)_INCLUDEDIR} != "x"],
        [AC_SUBST([$(my.cname)_ISYS_CPPFLAGS], ["-isystem${$(my.cname)_INCLUDEDIR} ${$(my.cname)_OTHER_CFLAGS}"])],
        [AC_SUBST([$(my.cname)_ISYS_CPPFLAGS], [${$(my.cname)_OTHER_CFLAGS}])])
     AC_MSG_NOTICE([$(my.cname)_CPPFLAGS : ${$(my.cname)_CPPFLAGS}])
     AC_MSG_NOTICE([$(my.cname)_ISYS_CPPFLAGS : ${$(my.cname)_ISYS_CPPFLAGS}])
     AC_MSG_NOTICE([$(my.cname)_OTHER_CFLAGS : ${$(my.cname)_OTHER_CFLAGS}])
     AC_MSG_NOTICE([$(my.cname)_INCLUDEDIR : ${$(my.cname)_INCLUDEDIR}])
     AC_MSG_NOTICE([$(my.cname)_LIBS : ${$(my.cname)_LIBS}])],
    [AC_SUBST([$(my.cname)_PKG], [])])
.   else
AS_CASE([${$(my.symbol)}], [yes],
    [PKG_CHECK_MODULES([$(my.cname)], [$(my.check)],
        [$(my.cname)_INCLUDEDIR="`$PKG_CONFIG --variable=includedir "$(my.check)" 2>/dev/null`"
         $(my.cname)_OTHER_CFLAGS="`$PKG_CONFIG --cflags-only-other "$(my.check)" 2>/dev/null`"
         $(my.symbol)="`$PKG_CONFIG --variable=$(my.dependency.extract) "$(my.check)" 2>/dev/null`"],
        [$(my.cname)_INCLUDEDIR=""
         $(my.cname)_OTHER_CFLAGS=""
         $(my.symbol)="$(my.default)"])
     AC_SUBST([$(my.cname)_PKG], ['$(my.check)'])
     AC_SUBST([$(my.cname)_CPPFLAGS], [${$(my.cname)_CFLAGS}])
     AS_IF([test x${$(my.cname)_INCLUDEDIR} != "x"],
        [AC_SUBST([$(my.cname)_ISYS_CPPFLAGS], ["-isystem${$(my.cname)_INCLUDEDIR} ${$(my.cname)_OTHER_CFLAGS}"])],
        [AC_SUBST([$(my.cname)_ISYS_CPPFLAGS], [${$(my.cname)_OTHER_CFLAGS}])])
     AC_MSG_NOTICE([$(my.cname)_CPPFLAGS : ${$(my.cname)_CPPFLAGS}])
     AC_MSG_NOTICE([$(my.cname)_ISYS_CPPFLAGS : ${$(my.cname)_ISYS_CPPFLAGS}])
     AC_MSG_NOTICE([$(my.cname)_OTHER_CFLAGS : ${$(my.cname)_OTHER_CFLAGS}])
     AC_MSG_NOTICE([$(my.cname)_INCLUDEDIR : ${$(my.cname)_INCLUDEDIR}])
     AC_MSG_NOTICE([$(my.cname)_LIBS : ${$(my.cname)_LIBS}])],
    [AC_SUBST([$(my.cname)_PKG], [])])
.   endif

AS_CASE([${enable_isystem}],[yes],
    [AC_SUBST([$(my.cname)_BUILD_CPPFLAGS], [${$(my.cname)_ISYS_CPPFLAGS}])],
    [AC_SUBST([$(my.cname)_BUILD_CPPFLAGS], [${$(my.cname)_CPPFLAGS}])])

AC_MSG_NOTICE([$(my.cname)_BUILD_CPPFLAGS : ${$(my.cname)_BUILD_CPPFLAGS}])

.endmacro
.
.#-----------------------------------------------------------------------------
.# Compound flags AX_CHECK_COMPILE_FLAG
.#-----------------------------------------------------------------------------
.macro render_compound_flags(compound, repository)
.   define my.compound = render_compound_flags.compound
.   require(my.compound, "compound", "name")
.   require(my.compound, "compound", "comment")
.   define my.repository = render_compound_flags.repository
.
.   if defined(my.compound.option)
.       define my.option = my.repository->configure->option(name = my.compound.option)
.       if !defined(my.option)
.           abort("Matching option '$(my.compound.option)' not found for '$(my.compound.name)'.")
.       endif
.   endif
.
.   define my.indent = defined(my.option) ?? "    " ? ""
.   define my.flags = join_flags_name(my.compound)
.   define my.terminator = "])"
.
.   if defined(my.option)
.       my.terminator = "])])"
AS_IF([test x${$(get_option_symbol(my.option))} != "xno"],
    [AX_CHECK_COMPILE_FLAG([$(my.flags)],
.   else
AX_CHECK_COMPILE_FLAG([$(my.flags)],
.   endif
    $(my.indent)[AC_DEFINE([$(my.compound.type:upper)_$(my.compound.name:upper)])
    $(my.indent) CXXFLAGS="$CXXFLAGS $(my.flags)";
    $(my.indent) AC_SUBST([$(my.compound.name:lower)], ["$(my.flags)"])],
    $(my.indent)[AC_MSG_ERROR([$(my.flags) not supported.])],
.   if defined(my.compound->program)
.       define my.prog_indent = "    $(my.indent)"
.       define my.prog_prefix = "    $(my.indent)["
    $(my.indent)[],
.       render_test_program(my.compound->program, my.prog_indent, my.prog_prefix, my.terminator)
.   else
    $(my.indent)[$(my.terminator)
.   endif

.endmacro
.
.#-----------------------------------------------------------------------------
.# AX_CHECK_XXX_FLAG
.#-----------------------------------------------------------------------------
.macro render_flag(flag)
.   define my.flag = render_flag.flag
.   require(my.flag, "flag", "name")
.   require(my.flag, "flag", "comment")
.
.   define my.flags_variable = get_flags_variable(my.flag)
.   define my.flags_check = get_flags_check(my.flag)
.   define my.show_disabled = is_empty(my.flag.compiler) | (my.flag.compiler = "disabled")
.   define my.show_compiler = my.show_disabled ?? "" ? " Enabled in $(my.flag.compiler) only."
.   define my.compiler_pattern = is_empty(my.flag.compiler) ?? "*" ? "*$(my.flag.compiler)*"
.   heading2("$(my.flag.comment)$(my.show_compiler)")
.
.   define my.check_terminator = defined(my.flag.alternate) ?? "," ? ")])"
.
AS_CASE([${CC}], [$(my.compiler_pattern)],
    [AX_CHECK_$(my.flags_check)_FLAG([-$(my.flag.name)],
        [$(my.flags_variable)="$$(my.flags_variable) -$(my.flag.name)"]$(my.check_terminator)
.   if (defined(my.flag.alternate))
        [AX_CHECK_$(my.flags_check)_FLAG([-$(my.flag.alternate)],
            [$(my.flags_variable)="$$(my.flags_variable) -$(my.flag.alternate)"])])])
.   endif

.endmacro
.
.#-----------------------------------------------------------------------------
.# AC_SUBST
.#-----------------------------------------------------------------------------
.macro output_value(name, value)
.   if (defined(my.value))
.       heading2("Output ${$(my.name)}")
AC_SUBST([$(my.name)], [$(my.value)])
.   endif

.endmacro
.
.#-----------------------------------------------------------------------------
.# AC_OUTPUT
.#-----------------------------------------------------------------------------
.macro compile(files)
AC_CONFIG_FILES([$(my.files)])
AC_OUTPUT
.endmacro
.
.endtemplate
.template 0
###############################################################################
# Generation
###############################################################################
function generate_configure(path_prefix)
for generate.repository by name as _repository

    require(_repository, "repository", "name")
    define my.output_path = join(my.path_prefix,\
        canonical_path_name(_repository))

    create_directory(my.output_path)
    define my.out_file = "$(my.output_path)/configure.ac"
    notify(my.out_file)
    output(my.out_file)

    copyleft(_repository.name)
    define my.configure = _repository->configure

    heading1("Standard declarations.")
    initialize_configure(_repository)
    require_stdcxx(_repository)

    if (defined(my.configure->option))
        heading1("Process options.")
        for my.configure.option as _option
            render_option(_option)
        endfor
    endif

    new isystem_option as _isystem
        _isystem.type = "enable"
        _isystem.name = "isystem"
        _isystem.default = "no"
        _isystem.description = "Substitute -isystem for -I in dependencies."
        render_option(_isystem)
    endnew

    if (defined(my.configure->define))
        heading1("Set preprocessor defines.")
        for my.configure.define as _define
            render_define_item(_define, my.configure)
        endfor
    endif

    if (defined(my.configure->flag))
        heading1("Set flags.")
        for my.configure.flag as _flag
            render_flag(_flag)
        endfor
    endif

    if (defined(my.configure->compound))
        heading1("Set flags for compound flags.")
        for my.configure.compound as _compound
            render_compound_flags(_compound, _repository)
        endfor
    endif

    if (defined(my.configure->dependency))
        heading1("Check dependencies.")
        for my.configure.dependency as _dependency where has_m4(_dependency)
            if (is_boost_dependency(_dependency))
                check_boost(_dependency)
            elsif (is_boost_lib_dependency(_dependency))
                check_boost_lib(_dependency, my.configure)
            elsif (is_java_dependency(_dependency))
                check_java(_dependency, my.configure)
            elsif (is_python_dependency(_dependency))
                check_python(_dependency, my.configure)
            elsif (is_package_dependency(_dependency))
                check_package(_dependency, my.configure)
            elsif (is_pthread_dependency(_dependency))
                check_m4_cpp_libs_conditional(_dependency, my.configure)
            elsif (is_iconv_dependency(_dependency))
                check_iconv(_dependency, my.configure)
            else
                check_lib_dependency_conditional(_dependency, my.configure)
            endif
        endfor
    endif

    heading1("Process outputs into templates.")
    define my.packages = get_package_files(_repository)
    define my.templates = format_template_files(my.configure)
    compile("Makefile$(my.packages)$(my.templates)")

    close
endfor _repository
endfunction # generate_configure
###############################################################################
# NOTES on: -all-static
# Always choose static libraries where possible, and try to create a completely
#  statically linked executable.
# -static is interpreted by libtool, where it has a different meaning.
# In libtool-speak, it's -all-static.
# AX_CHECK_LINK_FLAG([[-static]],[LIBTOOL_APP_LDFLAGS="$LIBTOOL_APP_LDFLAGS -all-static"])
# AC_SUBST(LIBTOOL_APP_LDFLAGS)
###############################################################################
.endtemplate
.template 0
###############################################################################
# Execution
###############################################################################
[global].root = ".."
[global].trace = 0
[gsl].ignorecase = 0

# Note: expected context root libbitcoin-build directory
gsl from "library/math.gsl"
gsl from "library/string.gsl"
gsl from "library/collections.gsl"
gsl from "utilities.gsl"

generate_configure("output")

.endtemplate
