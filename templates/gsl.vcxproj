.template 0
###############################################################################
# Copyright (c) 2014-2015 libbitcoin developers (see COPYING).
#
# GSL generate libbitcoin Makefile.am.
#
# This is a code generator built using the iMatix GSL code generation
# language. See https://github.com/imatix/gsl for details.
###############################################################################
# Functions
###############################################################################

###
### File element-related string data storage/query
###
function match_file_element_build_path(element, build_path)
    define my.element = match_file_element_build_path.element
    return defined(my.element) & (my.element.build_path = my.build_path)
endfunction

function match_file_element_path_prefix(element, path_prefix)
    define my.element = match_file_element_path_prefix.element
    return defined(my.element) &\
        ((!defined(my.element.path_prefix) & !defined(my.path_prefix)) |\
        (my.element.path_prefix = my.path_prefix))
endfunction

function match_file_element_file_name(element, file_name)
    define my.element = match_file_element_file_name.element
    return defined(my.element) & (my.element.file_name = my.file_name)
endfunction

function match_file_element(element, build_path, path_prefix, file_name)
    define my.element = match_file_element.element
    return defined(my.element) &\
        match_file_element_build_path(my.element, my.build_path) &\
        match_file_element_path_prefix(my.element, my.path_prefix) &\
        match_file_element_file_name(my.element, my.file_name)
endfunction

function exists_file_element(root, build_path, path_prefix, file_name)
    define my.root = exists_file_element.root
    return count(my.root.element, match_file_element(count, my.build_path,\
        my.path_prefix, my.file_name)) > 0
endfunction

function collides_file_element_file_name(root, file_name)
    define my.root = collides_file_element_file_name.root
    return count(my.root.element,\
        match_file_element_file_name(count, my.file_name)) > 1
endfunction

function add_file_element(root, build_path, path_prefix, file_name)
    define my.root = add_file_element.root
    if (defined(my.root) & !exists_file_element(my.root, my.build_path,\
        my.prefix_path, my.file_name))

        new my.root.element as _element
            _element.build_path = my.build_path
            if (!is_empty(my.path_prefix))
                _element.path_prefix = my.path_prefix
            endif
            _element.file_name = my.file_name
        endnew
    endif
    return my.root
endfunction

###
### File name collision-related data storage/query
###
function match_collision(collision, file_name)
    define my.collision = match_collision.collision
    return defined(my.collision) &\
        (my.collision.file_name = my.file_name)
endfunction

function exists_collision(root, file_name)
    define my.root = exists_collision.root
    return count(my.root.collision, match_collision(count, my.file_name)) > 0
endfunction

function add_collision(root, file_name)
    define my.root = add_collision.root
    if (defined(my.root) & !exists_collision(my.root, my.file_name))
        new my.root.collision as _collision
            _collision.file_name = my.file_name
        endnew
    endif
    return my.root
endfunction

###
### vcxproj related string generators
###
function project_base(product, repository_name)
    define my.product = project_base.product
    if (defined(my.product.option))
        return "$(my.repository_name)-$(_product.option)"
    endif
    return "$(my.repository_name)"
endfunction

function project_build_dir_relative_path(product, repository_name)
    define my.product = project_build_dir_relative_path.product
    define my.proj_name = project_base(my.product, my.repository_name)
    return "$(my.repository_name)/builds/msvc/vs2013/$(my.proj_name)"
endfunction

function project_file(product, repository_name)
    define my.product = project_file.product
    define my.proj_relative_path = project_build_dir_relative_path(my.product,\
        my.repository_name)
    define my.proj_name = project_base(my.product, my.repository_name)
    return "$(my.proj_relative_path)/$(my.proj_name).vcxproj"
endfunction

function append_prefix(base, subdir)
    if (!is_empty(my.base))
        return "$(my.base)_$(my.subdir)"
    endif
    return "$(my.subdir)"
endfunction

function append_win_path(base, subdir)
    return "$(my.base)\\$(my.subdir)"
endfunction

function append_path(base, subdir)
    return "$(my.base)$(my.subdir)"
endfunction

###
### generic assistance functions
###
function discover_files(file_data, directory, win_path, prefix, recurse)
    define my.file_data = discover_files.file_data
    define my.directory = discover_files.directory

#    echo("Listing directory $(my.directory.path)")
    for my.directory.file as _file by _file.name
#        echo("    $(_file.name)")
        add_file_element(my.file_data, append_win_path(my.win_path,\
            _file.name), my.prefix, _file.name)
    endfor

    if (is_true(my.recurse))
        for my.directory.directory as _directory by _directory.name
            define my.subdir_path = append_path(my.directory.path,\
                _directory.name)
            define my.subdir = open_directory(my.subdir_path)
            define my.subdir_win_path = append_win_path(my.win_path,\
                _directory.name)
            define my.subdir_prefix = append_prefix(my.prefix, _directory.name)

            discover_files(my.file_data, my.subdir, my.subdir_win_path,\
                my.subdir_prefix, my.recurse)
        endfor
    endif

endfunction

function populate_collisions(collisions, file_data)
    define my.collisions = populate_collisions.collisions
    define my.file_data = populate_collisions.file_data

    for my.file_data.element as _element
        if (collides_file_element_file_name(my.file_data, _element.file_name))
            add_collision(my.collisions, _element.file_name)
        endif
    endfor
endfunction

function is_compiled_type(element)
    define my.element = is_compiled_type.element
    return matches_filetype(my.element.file_name, "cpp") |\
        matches_filetype(my.element.file_name, "c")
endfunction

function is_included_type(element)
    define my.element = is_included_type.element
    return matches_filetype(my.element.file_name, "hpp") |\
        matches_filetype(my.element.file_name, "h")
endfunction

function is_none_type(element)
    define my.element = is_none_type.element
    return matches_filetype(my.element.file_name, "ipp")
endfunction

function is_resources_type(element)
    define my.element = is_resources_type.element
    return matches_filetype(my.element.file_name, "rc")
endfunction

function object_base_from_element(element)
    define my.element = object_base_from_element.element
    if (matches_filetype(my.element.file_name, "cpp"))
        return global.left(my.element.file_name,\
            string.length(my.element.file_name) - 4)
    elsif (matches_filetype(my.element.file_name, "c"))
        return global.left(my.element.file_name,\
            string.length(my.element.file_name) - 2)
    endif

    return my.element.file_name
endfunction

function matches_filetype(file_name, extension)
    return (regexp.match("(^.)(.*)\\.$(my.extension)$", my.file_name) > 0)
endfunction

###
### functional artifact emission
###
function emit_item_group_compiler(file_data, collisions)
    define my.file_data = emit_item_group_compiler.file_data
    define my.collisions = emit_item_group_compiler.collisions

    if (count(my.file_data.element, is_compiled_type(count)) > 0)
        emit_item_group_open()

        for my.file_data.element as _element by _element.build_path
            if (is_compiled_type(_element))
                #echo("    $(_element.build_path)")
                emit_compile_item(my.collisions, _element)
            endif
        endfor

        emit_item_group_close()
    endif
endfunction

function emit_item_group_includes(file_data, collisions)
    define my.file_data = emit_item_group_includes.file_data
    define my.collisions = emit_item_group_includes.collisions

    if (count(my.file_data.element, is_included_type(count)) > 0)
        emit_item_group_open()

        for my.file_data.element as _element by _element.build_path
            if (is_included_type(_element))
                #echo("    $(_element.build_path)")
                emit_include_item(_element)
            endif
        endfor

        emit_item_group_close()
    endif
endfunction

function emit_item_group_none(file_data, collisions)
    define my.file_data = emit_item_group_none.file_data
    define my.collisions = emit_item_group_none.collisions

    emit_item_group_open()

    for my.file_data.element as _element by _element.build_path
        if (is_none_type(_element))
            #echo("    $(_element.build_path)")
            emit_none_item(_element)
        endif
    endfor

    new element as _element
        _element.build_path = "packages.config"
        emit_none_item(_element)
    endnew

    emit_item_group_close()
endfunction

function emit_item_group_resources(file_data, collisions)
    define my.file_data = emit_item_group_resources.file_data
    define my.collisions = emit_item_group_resources.collisions

    if (count(my.file_data.element, is_resources_type(count)) > 0)
        emit_item_group_open()

        for my.file_data.element as _element by _element.build_path
            if (is_resources_type(_element))
                #echo("    $(_element.build_path)")
                emit_resources_item(_element)
            endif
        endfor

        emit_item_group_close()
    endif
endfunction

function emit_project(repository, product, project_path)
    define my.repository = emit_project.repository
    define my.product = emit_project.product
    require(my.product, "product", "path")
    require(my.product, "product", "prefix")
    require(my.product, "product", "uuid")
    define my.product_path = "$(my.project_path)/$(my.product.path)"
    define my.product_dir = open_directory(my.product_path)
    define my.product_offset = "..\\..\\..\\..\\$(my.product.path)"

    emit_xml_declaration(my.project_path, "12.0")

    # scan files (product, conditionally 'includes', build relative resources)
    new encountered_files as _files
        discover_files(_files, my.product_dir, my.product_offset,\
            my.product.path, "true")

        new collisions as _map
            populate_collisions(_map, _files)

            # TODO: consider providing this relationship in xml
            if (match_prefix(my.product, "lib"))
                define my.include_path = "$(my.project_path)/include"
                define my.include_dir = open_directory(my.include_path)

                discover_files(_files, my.include_dir, my.product_offset,\
                    "include", "true")

                define my.resources_path = "$(my.project_path)/builds/msvc"
                define my.resources_dir = open_directory(my.resources_path)
                discover_files(_files, my.resources_dir, "..\\..",\
                    "build", "false")
            endif

            emit_item_group_compiler(_files, _map)
            emit_item_group_includes(_files, _map)
            emit_item_group_none(_files, _map)
            emit_item_group_resources(_files, _map)
        endnew
    endnew

    emit_xml_close()
endfunction emit_project

###############################################################################
# Macros
###############################################################################
.endtemplate
.template 1
.
.macro emit_xml_declaration(project_path, version)
<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="$(my.version)" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <path>$(my.project_path)</path>
.endmacro emit_xml_declaration
.
.macro emit_xml_close()
</Project>
.endmacro emit_xml_close
.
.macro emit_item_group_open()
  <ItemGroup>
.endmacro emit_item_group_open
.
.macro emit_item_group_close()
  </ItemGroup>
.endmacro emit_item_group_close
.
.macro emit_compile_item(collisions, file_record)
.   define my.collisions = emit_compile_item.collisions
.   define my.file_record = emit_compile_item.file_record
.
.   if (!exists_collision(my.collisions, my.file_record.file_name))
    <ClCompile Include="$(my.file_record.build_path)" />
.   else
.       define my.object_base_name = object_base_from_element(my.file_record)
    <ClCompile Include="$(my.file_record.build_path)">
      <ObjectFileName>\$(IntDir)$(my.file_record.path_prefix)_$(my.object_base_name).obj</ObjectFileName>
    </ClCompile>
.   endif
.endmacro emit_compile_item
.
.macro emit_include_item(file_record)
.   define my.file_record = emit_include_item.file_record
.
    <ClInclude Include="$(my.file_record.build_path)" />
.
.endmacro emit_include_item
.
.macro emit_none_item(file_record)
.   define my.file_record = emit_none_item.file_record
.
    <ClNone Include="$(my.file_record.build_path)" />
.
.endmacro emit_none_item
.
.macro emit_resources_item(file_record)
.   define my.file_record = emit_resources_item.file_record
.
    <ResourceCompile Include="$(my.file_record.build_path)" />
.
.endmacro emit_none_item
.
.endtemplate
.template 0
###############################################################################
# Generation
###############################################################################
function generate_vcxproj()
    for generate.repository as _repository by _repository.name\
        where defined(_repository->make)

        require(_repository, "repository", "name")
        define my.make = _repository->make
        define my.absolute_proj_path = "$(global.root)/$(_repository.name)"

        for _repository->make.product as _product where \
            (defined(_product.uuid) & defined(_product.path))

            define my.proj_dir_name = project_build_dir_relative_path(\
                _product, _repository.name)

            define my.proj_file = project_file(_product, _repository.name)

            create_directory(my.proj_dir_name)
            notify(my.proj_file)
            output(my.proj_file)

            emit_project(_repository, _product, my.absolute_proj_path)

            close
        endfor
    endfor _repository
endfunction # generate_vcxproj
.endtemplate
.template 0
###############################################################################
# Execution
###############################################################################
[global].root = ".."
[global].trace = 0
[gsl].ignorecase = 0

# Note: expected context root libbitcoin-build directory
gsl from "library/math.gsl"
gsl from "library/string.gsl"
gsl from "library/collections.gsl"
gsl from "utilities.gsl"

generate_vcxproj()

.endtemplate
